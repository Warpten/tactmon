#pragma once

#include "io/fs/FileStream.hpp"
#include "io/net/Download.hpp"
#include "net/DownloadTask.hpp"
#include "logging/Sinks.hpp"

#include "net/ribbit/types/CDNs.hpp"
#include "net/ribbit/types/Versions.hpp"

#include "tact/config/BuildConfig.hpp"
#include "tact/config/CDNConfig.hpp"
#include "tact/data/Encoding.hpp"
#include "tact/data/Install.hpp"
#include "tact/data/Index.hpp"
#include "tact/CKey.hpp"

#include <filesystem>
#include <functional>
#include <optional>
#include <type_traits>

#include <boost/asio/io_context.hpp>

namespace io {
    struct LocalCache final {
        LocalCache(std::filesystem::path installationRoot, net::ribbit::types::CDNs const& cdns, net::ribbit::types::versions::Record const& version, boost::asio::io_context& ctx);

        /**
         * Resolves a configuration file.
         * 
         * @param[in] key    The MD5 hash of the config file.
         * @param[in] parser A function that parses the configuration file.
         * 
         * @returns The parsed configuration object, or an empty optional if an error occured.
         */
        template <typename T>
        std::optional<T> ResolveConfig(std::string_view key, std::function<std::optional<T>(io::IReadableStream&)> parser) const {
            for (net::ribbit::types::cdns::Record const& cdn : _cdns) {
                std::string remotePath{ std::format("{}/config/{}/{}/{}", cdn.Path, key.substr(0, 2), key.substr(2, 2), key) };
                std::filesystem::path localPath = _installRoot / remotePath;

                if (std::filesystem::is_regular_file(localPath)) {
                    io::FileStream fileStream{ localPath, std::endian::little };
                    std::optional<T> parsedValue = parser(fileStream);
                    if (parsedValue.has_value())
                        return parsedValue;
                }

                for (std::string_view host : cdn.Hosts) {
                    if (!io::Download(_context, host, remotePath, localPath))
                        continue;

                    io::FileStream fileStream { localPath, std::endian::little };

                    std::optional<T> parsedValue = parser(fileStream);
                    if (parsedValue.has_value())
                        return parsedValue;
                }
            }

            return std::nullopt;
        }

        /**
         * Resolves a data file.
         * 
         * @param[in] taskSupplier A function returning the task used to download said file.
         * @param[in] resultSupplier A function that parses the data file.
         * 
         * @returns The parsed data file, or an empty optional if an error occured.
         */
        template <typename Task, typename R>
        // requires std::is_base_of_v<net::DownloadTask, Task>
        std::optional<R> ResolveData(std::function<Task()> taskSupplier,
            std::function<std::optional<R>(typename Task::ValueType&)> resultSupplier) const
        {
            Task downloadTask = taskSupplier();

            for (net::ribbit::types::cdns::Record const& cdn : _cdns) {
                std::string_view queryPath = cdn.Path;

                for (std::string_view host : cdn.Hosts) {
                    auto taskResult = downloadTask.Run(_context,
                        host, std::format("{}/data", cdn.Path), _logger);
                    if (taskResult.has_value())
                        return resultSupplier(*taskResult);
                }
            }

            return std::nullopt;
        }

        /**
         * Resolves a cached file data.
         * 
         * @param[in] resourcePath Path on disk to the resource.
         * @param[in] resultSupplier A function that deserializes the resource.
         * 
         * @returns An optional encapsulating the deserialized resource.
         */
        template <typename R>
        std::optional<R> ResolveCachedData(std::filesystem::path resourcePath,
            std::function<std::optional<R>(io::IReadableStream&)> resultSupplier) const {

            namespace fs = std::filesystem;

            if (fs::is_regular_file(resourcePath)) {
                io::FileStream fs { resourcePath, std::endian::little };
                return resultSupplier(fs);
            }

            net::FileDownloadTask fileTask { resourcePath.filename(), resourcePath };
            
            for (net::ribbit::types::cdns::Record const& cdn : _cdns) {
                std::string_view queryPath = cdn.Path;

                for (std::string_view host : cdn.Hosts) {
                    auto taskResult = fileTask.Run(_context,
                        host, std::format("{}/data", cdn.Path), _logger);

                    if (taskResult.has_value() && fs::is_regular_file(resourcePath)) {
                        io::FileStream fs{resourcePath, std::endian::little};
                        return resultSupplier(fs);
                    }
                }
            }

            return std::nullopt;
        }

        template <typename Task>
        std::optional<tact::BLTE> ResolveBLTE(std::function<Task()> taskSupplier) {
            return ResolveData(taskSupplier, [](typename Task::ValueType& result) {
                io::mem::GrowableMemoryStream ms{ result.data(), std::endian::little };
                return tact::BLTE::Parse(ms);
            });
        }

    public:
        size_t GetContentKeySize() const;

        std::optional<tact::config::BuildConfig> const& GetBuildConfig() const { return _buildConfig; }

        std::optional<tact::data::FileLocation> FindFile(tact::CKey const& ckey) const;
        std::optional<tact::CKey> FindFile(std::string_view fileName) const;

        std::shared_ptr<spdlog::logger> GetLogger() const;

        std::optional<tact::data::IndexFileLocation> FindIndex(tact::EKey const& ekey) const;

    private:
        boost::asio::io_context& _context;
        std::shared_ptr<spdlog::logger> _logger;

    private:
        std::filesystem::path _installRoot;
        net::ribbit::types::CDNs _cdns;
        net::ribbit::types::versions::Record _version;

        std::optional<tact::config::BuildConfig> _buildConfig;
        std::optional<tact::config::CDNConfig> _cdnConfig;

        std::optional<tact::data::Encoding> _encoding;
        std::optional<tact::data::Install> _install;
        std::vector<tact::data::Index> _indices;
    };
}
